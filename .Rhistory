title(main="Euler's Algorithm")
title(main="Taylor Series approximation to ODEs")
# initial values
y_0 <- 1; yprime_0 <- 1;
plot(x=c(0,0), y=c(y_0, yprime_0),
xlim=c(-5, 5), ylim=c(-5, 5), pch=20)
abline(h=0, col="grey")
abline(v=0, col="grey")
# set degree
n <- 10
#set line type
k <- 1
#y1
curve(y1_approx(x,degree=n), from=-5, to=5,
col="blue", lty=k, lwd=2, add=TRUE)
#y2
curve(y2_approx(x,degree=n), from=-5, to=5,
col="orange", lty=k, lwd=2, add=TRUE)
#y = a_0 y1 + a_1 y2
curve(y_approx(x,degree=n), from=-5, to=5,
col="purple", lty=k, lwd=2, add=TRUE)
# add title and legend
legend(0.5, -2, legend=c("y_1(x)", "y_2(x)", "general y(x)"),
col=c("blue","orange", "purple"),lty=k, lwd=2)
title(main="Taylor Series approximation to ODEs")
# symbolic solution
solution <- function(x, y_0){(y_0-2)*exp(-x) + x^2 - 2*x + 2}
# plot the five initial values
plot(rep(0,times=5), y=seq(-2, 2), pch =19,
xlim=c(-2,2), ylim=c(-20, 10), xlab="x", ylab="y")
# plot the IVP solutions
curve(solution(x, y_0 = -2), add=TRUE)  #for y_0=-2
curve(solution(x, y_0 = -1), add=TRUE)  # for y_0=-1
curve(solution(x, y_0 = 0),add=TRUE)    # for y_0=0
curve(solution(x, y_0 = 1), add=TRUE)   # for y_0=1
curve(solution(x, y_0 = 2),add=TRUE)    # for y_0=2
#title
title(main="Actual solutions to IVPs")
# create the ode
ode = function(x, y){
dydx <- x^2 -y
list(dydx)
}
# user-defined function to plot slope field "estimates"
SlopeField(ode, xi = -2, xs = 2, yi = -5, ys = 5,radius = 0.1, grid.by = 0.2)
abline(h=0, col="grey")
abline(v=0, col="grey")
# Plot symbolic solution from previous page
points(rep(0, 5), seq(-2, 2))
curve(solution(x, y_0 = -2), add=TRUE)  # IVP for y_0=-2
curve(solution(x, y_0 = -1), add=TRUE) # for y_0=-1
curve(solution(x, y_0 = 0),add=TRUE)  # for y_0=0
curve(solution(x, y_0 = 1), add=TRUE)  # for y_0=1
curve(solution(x, y_0 = 2),add=TRUE)  # for y_0=2
#### for storing our estimates, not part of the algorithm:
estimates <- data.frame("h"= 0, "x"=0, "y_est"=0, "error"= 0)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 1 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = y
F <- function(x,y){y}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
estimates[-1, ]
# plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# add title and legend
legend(.5, 1.4, legend=c("f(x)", "Euler's algorithm"), col=c("black", "blue"),lty=1:2, lwd=2)
title(main="Euler's Algorithm")
N <- 5 # number of steps
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 5 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = y
F <- function(x,y){y}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
estimates[-1, ]
# plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
N <- 10 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = y
F <- function(x,y){y}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
# discussing solutions
solutions
estimates[-1, ]
# plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# add title and legend
legend(.5, 1.4, legend=c("f(x)", "Euler's algorithm"), col=c("black", "blue"),lty=1:2, lwd=2)
title(main="Euler's Algorithm")
N <- 100 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = y
F <- function(x,y){y}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
solutions
estimates[-1, ]
# plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# plot
curve(exp(x),
lwd=2), xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# plot
curve(exp(x),
lwd=2, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
N <- 1000 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = y
F <- function(x,y){y}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
solutions
# discussing solutions
tail(solutions)
estimates[-1, ]
# plot
curve(exp(x),
lwd=2, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# add title and legend
legend(.5, 1.4, legend=c("f(x)", "Euler's algorithm"), col=c("black", "blue"),lty=1:2, lwd=2)
title(main="Euler's Algorithm")
#### for storing our estimates, not part of the algorithm:
estimates <- data.frame("h"= 0, "x"=0, "y_est"=0, "error"= 0)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 10 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = sin(x) + ln(y)
F <- function(x,y){sin(x) + log(y)}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
estimates[-1, ]
# discussing solutions
tail(solutions)
estimates[-1, ]
N <- 100 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = sin(x) + ln(y)
F <- function(x,y){sin(x) + log(y)}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
estimates[-1, ]
N <- 10000 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = sin(x) + ln(y)
F <- function(x,y){sin(x) + log(y)}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discussing solutions
tail(solutions)
estimates[-1, ]
N <- 1000000 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3, set differential equation dy/dx = f(x,y) = sin(x) + ln(y)
F <- function(x,y){sin(x) + log(y)}
# step 4, update x and y
y <- y + h* F(x, y)
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
#### for storing our estimates, not part of the algorithm:
estimates <- data.frame("h"= 0, "x"=0, "y_est"=0, "error"= 0)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 1 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discuss solutions
tail(solutions)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 1 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discuss solutions
tail(solutions)
estimates[-1, ]
#### for storing our estimates, not part of the algorithm:
estimates <- data.frame("h"= 0, "x"=0, "y_est"=0, "error"= 0)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 1 # number of steps
#### for storing our estimates, not part of the algorithm:
estimates <- data.frame("h"= 0, "x"=0, "y_est"=0, "error"= 0)
### algorithm starts
# Input constants
x_0 <- 0; y_0 <- 1 # initial value
c <- 1 # desired output
N <- 1 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discuss solutions
tail(solutions)
estimates[-1, ]
#plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
# add title and legend
legend(.5, 1.4, legend=c("f(x)", "Euler's algorithm"), col=c("black", "blue"),lty=1:2, lwd=2)
title(main="Euler's Improved Algorithm")
N <- 10 # number of steps
# Step 1: step size and initial x,y
h <- (c-x_0)/N
x <- x_0; y <- y_0
# for printing table later
solutions <- data.frame("x"=x_0, "y"=y_0)
#Step 2
for (i in 1:N){
# Step 3
# set differential equation dy/dx = f(x,y) = y for estimating slope
F <- function(x,y){y}
# set up function to estimate slope at the "next" point,
# using Euler's to estimate y_n+1
G <- function(x,y, h){F(x+h, y+h*F(x,y))}
# step 4, update x and y
y <- y + h*(F(x, y) +G(x,y, h))/2
x <- x + h
# step 5
solutions <- rbind(solutions, c(x, y))
if(i==N){estimates <- rbind(estimates, c(h,x, y, exp(1)-y))}
}
# discuss solutions
tail(solutions)
estimates[-1, ]
#plot
curve(exp(x),
lwd=2) #, xlim=c(0.7, 1))
points(solutions[,1], solutions[,2],
type="b", pch=20, col="blue", lty=2, lwd=2)
WD <- '~/Desktop'
setwd(WD)
devtools::create("Table1PKG")
WD2 <- '~/Desktop/Table1PKG'
setwd(WD2)
##' @export
f <- function(x, y) x + y
setwd(WD2)
## make the code neat
formatR::tidy_dir("R")
library(devtools)
devtools::document()
knitr::opts_chunk$set(echo = TRUE)
devtools::install(build_vignettes = TRUE)
setwd(WD2)
devtools::install(build_vignettes = TRUE)
# devtools::create("Table1PKG")
WD2 <- '~/Desktop/Table1PKG'
setwd(WD2)
devtools::install(build_vignettes = TRUE)
setwd(WD2)
devtools::document()
devtools::install(build_vignettes = TRUE)
remove.packages("Table1PKG")
install.packages(file.path("~/Desktop","Table1PKG_0.0.0.9000.tar.gz"),repos=NULL,type="source")
setwd(WD)
install.packages(file.path("~/Desktop","Table1PKG_0.0.0.9000.tar.gz"),repos=NULL,type="source")
library(Table1PKG)
setwd(WD2)
remove.packages("Table1PKG")
setwd(WD2)
setwd(WD2)
devtools::document()
devtools::install(build_vignettes = TRUE)
setwd(WD2)
install.packages(file.path("~/Desktop","Table1PKG_0.0.0.9000.tar.gz"),repos=NULL,type="source")
library(Table1PKG)
help(package="Table1PKG")
f(1,2)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(titanic)
library(rpart)
library(titanic)
install.packages("titanic")
library(titanic)
library(rpart)
library(rpart.plot)
install.packages("rpart.plot")
library(rpart.plot)
suppressMessages(library(randomForest))
install.packages("randomForest")
